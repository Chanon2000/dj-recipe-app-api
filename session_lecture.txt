[32. Database architecture overview]

Database ที่จะใช้คือ 
    - PostgreSQL
        - Popular open source DB
        - Integrates well with Django
    - ซึ่งจะรันโดยใช้ Docker Compose โดยจะใช้ทำอะไรหลายอย่างดังนี้
        - Defined with project (re-usable)
        - Persistent data using volumes
        - Handles network configuration
        - Environment variable configuration

        โดย Architecture ที่จะทำใน Docker Compose คือ
            - Database (PostgreSQL)
            - App (Django)

            2 service จะสื่อสารกันเช่น read และ write data บน Postgres database ได้

        Volumes
            - Persistent data
            - Maps directory in container to local machine

[33. Add database service]

เขียน docker-compose เสร็จก็ทำการรัน
"docker-compose up"

[34. Database configuration with Django]

Steps for configuring database
    - Configure Django
        - Tell Django how to connect
    - Install database adaptor dependencies
        - Install the tool Django uses to connect
    - Update Python requirements (เพราะเราเพิ่ม Postgres adapter เข้ามาเป็นต้น)

Django ต้องรู้อะไรบ้างเพื่อ connect กับ database (กำหนดใน settings.py)
    - Engine (type of database)
    - Hostname (IP or domain name for database)
    - Port (default ของ postgres คือ 5432)
    - Database Name
    - Username
    - Password

Environment variables (เราจะใช้ env var ยังไงบ้าง)
    เราจะกำหนด env var ใน docker-compose แล้วใส่ลง python
    - Pull config values from environment variables
    - Easily passed to Docker
    - Used in local dev or prod
    - Single place to configure project
    - Easy to do with Python => os.environ.get('DB_HOST')

    "Psycopy2" package => คือ connect Django กับ database (database adapter)
        - Most popular PostgreSQL adaptor for Python
        - Supported by Django

        มีหลายวิธีในการ install Psycopy2 เช่น
            "psycopy2-binary"
                - OK for development
                - Not good for production (เพราะมันไม่ค่อย optimize ต่อ os ที่ install แล้วก็ running มากนัก)
            "psycopg2"  (install โดยใช้ pip ได้เลย) (เราจะใช้อันนี้ใน course เรียน)
                - Compiles from source (compile มาจาก source code) (ถ้าเรา install ลง Linux มันก็จะ compile แบบที่ Linux ต้องการ นั้นคือ optimize ให้ os ที่ install แล้ว)
                - ข้อเสียคือ: Required additional dependencies (เราต้อง install อย่างอื่นเพิ่มเพื่อ compile)
                    # นี้คือเหตุผลว่าทำไมหลายคนถึงไปใช้ psycopy2-binary นั้นเป็นเพราะว่ามันไม่ต้องการ การ compile ซึ่งมันสามารถทำงานได้ดีในทุก machine แต่จะไม่ optimize มาก
                - install ง่ายบน docker (เพราะเราไม่ต้องสนว่าเครื่องเราจะเป็น os อะไร เพราะเรารันใน docker แล้วใช้ image เพื่อจัดการให้เราเองเลย)

                Installing Psycopy2
                จะมี package dependencies มากมายเพื่อที่จะ install Psycopy2 ได้แก่
                    - C compiler
                    - python3-dev
                    - libpg-dev

                และนี้คือ list ของ package ที่ควร install เมื่อเราใช้ Psycopy2 ใน Alpine image
                    - postgresql-client
                    - build-base
                    - postgresql-dev
                    - musl-dev

                * นี้คือข้อดีของการใช้ docker เพราะ dependencies เหล่านี้จะได้ไม่ต้องถูก install ลงเครื่องของคุณ แต่ install ที่ docker image แทน มันจะทำให้คุณ clean dependencies ได้ง่าย

[35. Install PostgreSQL database adaptor]

เมื่อปรับ Dockerfile และ requirements เสร็จก็รัน คำสั่งดังนี้

"docker-compose down" => เพื่อ clear container ใหม่
"docker-compose build" => เพื่อทำการ build image ใหม่

[36. Configure database in Django]

ลบ db.sqlite file ออกไดเลยเพราะเราไม่ได้ใช้

[37. Fixing database race condition]

ปัญหาเมื่อใช้ docker-compose รัน ซึ่งเกิดปัญหา database race condition
    - เมื่อเรากำหนด depends_on คือมันจะมั้นใจได้ว่า db นั้นรัน แต่ไม่สามารถมั้นใจได้ว่า app จะรันเช่นกัน

    การที่ database start เรียบร้อย ไม่ได้หมายความว่า มันจะพร้อมต่อการ connection เนื่องจากว่าเมื่อ service start สำเร็จมันจะใช้เวลาช่วงต่อมันในการ init postgres แล้วเมื่อเสร็จถึงจะทำการ connect ได้

    ซึ่งบางที่ app อาจจะ start เสร็จแล้วทำการ connect ตอนที่ postgres ยัง start ไม่เสร็จได้ ซึ่งถ้าเกิดกรณีนี้ app ก็จะแสดง exception และอาจจะแจ้ง error ว่า ไม่เจอ database ก่อนที่ postgres จะ start success

    ซึ่งเมื่อ Django app crashed เราก็คงต้อง restart service ใหม่อีกครั้ง

    ปัญหานี้สามารถเกิดได้ทั้งเมื่อรัน Local และทั้ง Production

    เกิดปัญหานี้ได้เมื่อ
        - Running docker-compose locally
        - Running on deployed environment

    Solution สำหรับปัญหานี้คือ
    - Make Django "wait for db"
        คือ custom Django management command ที่เราจะสร้าง ที่ทำให้เรารอจนกว่า database จะพร้อมก่อนที่เราจะเริ่ม running application
        - Check for database availability (มันจะเข้าไปตรวจสอบ database ว่าพร้อมแล้วยังเรื่อยๆ และเมื่อ database พร้อมมันก็จะทำการ continue application ให้ start)
        # ดังนั้นเราจะได้สร้าง custom Django management command

        ซึ่งเมื่อเราสร้าง Django command นี้

        เมื่อ app start มันจะทำการไป check database ด้วย method เช่น wait_for_db ซึ่งก็จะเรียกเรื่อยๆจนกว่า database จะพร้อม แล้ว app ก็จะทำการ connect กับ database ตอนนั้นแทน (ซึ่งทำให้ app ของเราไม่ crashed)

[38. Create core app]

เราจะสร้าง app ชื่อ core 
'docker-compose run --rm app sh -c "python manage.py startapp core"'

เราสามารถลบ test file ที่สร้างมาต้องสร้าง core app ได้เลย เพราะเราจะไม่ทำมันตรงนี้

และลบ views.py ด้วย เพราะ core app ของเราจะไม่ทำเกี่ยวกับการ serve web views ซึ่งจากเราจะใช้มันทำเกี่ยวกับ models, App Management Command

จากนั้นก็ทำการสร้าง tests folder และ __init__.py ลงใน core

[39. Write tests for wait_for_db command]

เขียน test เสร็จแบบ TDD ก็ลองรัน เพื่อทำการรัน test
'docker-compose run --rm app sh -c "python manage.py test"'